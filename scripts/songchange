#!/usr/bin/perl
# Polls for a song change in mpd and calls the command specified for each such
# event, substituting every occurrence of {} with the new song name.

use strict;
use warnings;
use IO::Socket;

my $host = ($ENV{MPD_HOST} || '127.0.0.1');
my $dbbase = $ENV{MPD_DB_ROOT};
my $last = '';
my $now = '';
my $child;

sub die_child {
    wait;
    undef $child;
    $SIG{CHLD} = \&die_child;
}

sub force_update {
    $last = '';
    $SIG{USR1} = \&force_update;
}

$SIG{CHLD} = \&die_child;
$SIG{USR1} = \&force_update;
$SIG{HUP} = sub { exit 0; };

unless (@ARGV) {
    print STDERR "No command specified\n";
    exit 1;
}

my $remote = IO::Socket::INET->new (Proto => 'tcp',
				    PeerAddr => $host,
				    PeerPort => '6600',)
    or die "Cannot connect to mpd port at $host";

# open LOG, "> $ENV{HOME}/.songch.log" or die "Open: $!";
# select (LOG) and $| = 1;

while (1) {
    until ($remote and $remote->connected) {
	$remote = IO::Socket::INET->new (Proto => 'tcp',
					 PeerAddr => $host,
					 PeerPort => '6600',)
	    and last;
	sleep 1;
    }
    print $remote "currentsong\n";
    $now = '';
    while (<$remote>) {
	$now = ($1 || '') if ((not $now) && /^file: (.*)/);
	last if /^OK$/;
    }
    if ($now ne $last) {
	if (defined ($child)) {
	    kill "TERM", $child;
	    wait;
	}
	defined ($child = fork) or die 'Unable to fork';
	if ($child) {
	    $last = $now;
	} else {
	    my $file = ($now ? $dbbase.'/'.$now : '');
	    my @command = ();
	    foreach (@ARGV) {
		s/{}/$file/g;
		push @command, $_;
	    }
	    exec @command;
	}
    }
    sleep 1;
}
